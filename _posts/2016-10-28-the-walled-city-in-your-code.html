---
layout: post
title: The walled city in your code
date: '2016-10-28T16:16:00.000-07:00'
author: Stryker
tags: 
modified_time: '2016-10-28T16:16:09.940-07:00'
thumbnail: https://i.ytimg.com/vi/r7oAAUsKssE/default.jpg
---

<h1 id="the-walled-city-in-your-code" style="text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/4/40/Casco_viejo_de_Dubrovnik%2C_Croacia%2C_2014-04-14%2C_DD_07.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="255" src="https://upload.wikimedia.org/wikipedia/commons/4/40/Casco_viejo_de_Dubrovnik%2C_Croacia%2C_2014-04-14%2C_DD_07.JPG" width="400" /></a></h1><div><br /></div>Walled cities have a really long history thanks to the fact that we love to kill each other for whatever reason. So city walls were a necessity from a very early history to modern times thanks to this fact. Of course a walled city also needs gates and guards who guard these gates and walls, so we feel a lot more safer. Nowadays we usual have fences, gates and security guards for the very same reason. <br />In this little post we will talk about when can our code feel a little bit safer.<br /><br /><div><br /></div><h2 id="an-important-lesson-from-haskell">An important lesson from Haskell</h2>You can learn a lot from a pure functional programming language like Haskell, because it makes us view and solve problems in a different way. For example Haskell considers every IO action dangerous, because it causes side effects and side effects can cause unforeseen errors. It’s also one of the most important from Haskell is to be wary of any IO action.<br /><br /><div><br /></div><h2 id="the-outside-world">The outside world</h2>The outside world is dangerous, because you can caught a cold or get hit by a bus. The “digital” outside world also has it’s own dangers like errors, exceptions and bad inputs, which are things that programmers hate the most. Unfortunately we can’t live without the outside world, because we need to get and share information, but we also want to get rid of the dangers, so what to do?<br /><br /><div><br /></div><h2 id="the-wall-around-the-city">The wall around the city</h2>We build walls to control the madness of the outside world and also to feel a lot safer. In our case the goal of the wall is to protect us from the errors, exceptions and bad inputs. Basically it’s job is to handle any exception or error from the outside and also to validate any incoming value. This wall also needs to be robust so it won’t crash the system and it will recover from any unforeseen error.<br /><br />For the wall we need a programming language, which can handle a lot of IO action, but it’s also robust against any exception or error.  <br />The best language for this role is Erlang or Elixir(which is basically Erlang with simpler syntax). Erlang is a good fit, because it’s scalable  and robust thanks to it’s lightweight green threads and the use of supervisor trees.<br /><br /><div><br /></div><h2 id="the-city-inside-the-wall">The city inside the wall</h2>We are inside of the walls in our little safe place,  far from the dangers of the world. Inside the wall is the ideal place to be, but it needs to be very strict to avoid causing any inside danger. We want to avoid causing any error or exception here, because it would spread like a fire through out the city. That’s why I said we need to be strict and so we need to use a programming language with strong type system that emphasis on avoiding anything that can cause side effects, exceptions or errors.<br /><br />The best choices for this role is Haskell or OCaml, because both of them are strongly typed language. A strong type system is important, because it can guarantee that there won’t be any type mismatch or null exception(billion dollar mistake). They are also high level(functional) languages, which means it restricts the freedom of it’s users, which is a really good thing when you are going for correctness. <br /><br />Another reason for using Haskell and Ocaml is that they both have a proof assistant based on them. Proof assistants are really important when you want to prove that your program works correctly. Proof assistants are basically really strict programming languages that can also be used for proving. These tools should be used, when you want really strong foundations for your city. <br /><br /><div><br /></div><h2 id="final-word">Final word</h2>This idea describes a system where the core of the system is protected by the outer layer, so this way the system can isolate itself from the environment and the only thing that matters is the logical correctness of it’s code base. This is also why I really like this idea. <br /><br /><br />I hope you liked my first post in english. :D<br />Best way to enjoy Autumn is to watch a Summer music clip. :D<br /><iframe allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/r7oAAUsKssE" width="560"></iframe>